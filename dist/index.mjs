var o=(i=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(i,{get:(r,t)=>(typeof require!="undefined"?require:r)[t]}):i)(function(i){if(typeof require!="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+i+'" is not supported')});import c from"path";import V from"fs";import g from"pkg-dir";var s=class i{static getLocalPath(){return g.sync(process.cwd())}static getPackageJSON(r){var n,e;return o(c.resolve((e=(n=g.sync(r))!=null?n:i.getLocalPath())!=null?e:"","package.json"))}static getVersion(r){let t=i.getPackageJSON(r!=null?r:"");if(!t)throw Error("Unable to find the package.json");return t.version}static setVersion(r,t,n){var a;let e=i.getPackageJSON(t);e.version=r,V.writeFileSync(c.resolve((a=i.getLocalPath())!=null?a:"","package.json"),JSON.stringify(e,null,n||4))}static parse(r){let t=/(\d+)\.?(\d+)?.?(\d+)?/i,n={major:0,minor:0,patch:0};if(r.match(t)){let[e,a,m,p]=r.match(t);n={major:parseInt(a.toString()),minor:parseInt(m.toString()),patch:parseInt(p.toString())}}return Object.entries(n).forEach(([e,a])=>a?n[e]=parseInt(a.toString()):n[e]=0),n}static stringify(r){return Object.values(r).reduce((t,n)=>`${t}.${n}`).toString()}static toSemver(r){return i.stringify(i.parse(r))}static increment(r,t){let n=i.parse(r);return n[t.toLowerCase()]++,(t==="major"||t==="minor")&&(n.patch=0),t==="major"&&(n.minor=0),i.stringify(n)}static major(r){return i.increment(r,"major")}static minor(r){return i.increment(r,"minor")}static patch(r){return i.increment(r,"patch")}};export{s as default};
//# sourceMappingURL=index.mjs.map